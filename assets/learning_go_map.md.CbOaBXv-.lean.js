import{_ as l,c as e,a0 as i,o}from"./chunks/framework.D-WqjATM.js";const c=JSON.parse('{"title":"Map","description":"","frontmatter":{},"headers":[],"relativePath":"learning/go/map.md","filePath":"learning/go/map.md"}'),r={name:"learning/go/map.md"};function t(n,a,h,p,s,d){return o(),e("div",null,a[0]||(a[0]=[i('<h1 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h1><h2 id="хэш-функция-требования" tabindex="-1">Хэш функция, требования: <a class="header-anchor" href="#хэш-функция-требования" aria-label="Permalink to &quot;Хэш функция, требования:&quot;">​</a></h2><ol><li>детерминированность. Хэш от одного и того же значения должен быть одинаковым</li><li>равномерное распределение по таблице, мало коллизий</li><li>быстрота операции хэширования</li></ol><h2 id="хэш-таблица" tabindex="-1">Хэш таблица <a class="header-anchor" href="#хэш-таблица" aria-label="Permalink to &quot;Хэш таблица&quot;">​</a></h2><p>таблица соответствия хэшу ключа и значения, позволяет быстро выполнить операции вставки, получения, удаления.</p><h2 id="map-1" tabindex="-1">Map <a class="header-anchor" href="#map-1" aria-label="Permalink to &quot;Map&quot;">​</a></h2><p>структура в go, которая позволяет все операции выполнить за константное время - O(1). Вставки, удаления, получения значения по ключу.</p><p>Структура map состоит из:</p><ul><li>размер map</li><li>log2 числа бакетов</li><li>ссылка на бакеты</li><li>hash seed</li></ul><h2 id="как-работает-операция-получения-значения-по-ключу" tabindex="-1">Как работает операция получения значения по ключу: <a class="header-anchor" href="#как-работает-операция-получения-значения-по-ключу" aria-label="Permalink to &quot;Как работает операция получения значения по ключу:&quot;">​</a></h2><ol><li>из ключа получаем его хэш</li><li>из хэша получаем LOB (low order bytes). из LOB получаем адрес нужного бакета</li><li>в бакете получаем из хэша получаем HOB (high order bytes). из hob получаем адрес ключа, а потом адрес значения. Если не найдено, возвращаем zero value.</li><li>при переполнении бакетов в бакете хранится ссылка на следующий бакет. поэтому если такая ссылка есть и HOB не найден, то идем в следующий бакет</li></ol><h2 id="особенности-map" tabindex="-1">Особенности Map: <a class="header-anchor" href="#особенности-map" aria-label="Permalink to &quot;Особенности Map:&quot;">​</a></h2><ol><li>осознанный рандомный обходы map в цикле</li><li>в каждом бакете 8 пар ключей и значений, сначала идут все ключи, потом все значения. В бакетах хранятся коллизии</li><li>при среднем значении заполненности бакетов в 6.5 происходит эвакуация бакетов. Бакетов становится в 2 раза больше</li><li>эвакуация бакетов постепенная при каждой вставке или удалении, поэтому операции чуть медленнее, но нет большой задержки в определенное время</li><li>из-за эвакуации бакетов нельзя брать ссылку на значение мапы, потому что после эвакуации эта ссылка будет неактуальна</li><li>также из-за эвакуации эффективнее выделять память заранее, если есть информация о количестве элементов</li></ol>',13)]))}const u=l(r,[["render",t]]);export{c as __pageData,u as default};
